# 1.Spring Security
Dependencies
```xml
<!-- Spring Security -->
<dependency>
	<groupId>org.springframework.boot</groupId>
	<artifactId>spring-boot-starter-security</artifactId>
</dependency>

<!-- JWT -->
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-api</artifactId>
	<version>0.11.5</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-impl</artifactId>
	<version>0.11.5</version>
</dependency>
<dependency>
	<groupId>io.jsonwebtoken</groupId>
	<artifactId>jjwt-jackson</artifactId>
	<version>0.11.5</version>
</dependency>
```
---
# 2.1 User
```java
package uz.pdp.archvizor.entity;

import com.fasterxml.jackson.annotation.JsonIgnore;
import com.fasterxml.jackson.annotation.JsonManagedReference;
import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;
import org.springframework.security.core.userdetails.UserDetails;
import uz.pdp.archvizor.entity.abs.AbsEntity;
import uz.pdp.archvizor.entity.enums.Gender;

import java.util.Collection;
import java.util.Set;
import java.util.UUID;

@Getter
@Setter
@ToString(exclude = {"password", "roles"})
@AllArgsConstructor
@NoArgsConstructor
@Entity
@Table(name = "users")
public class User extends BaseEntity implements UserDetails {

    @Column(name = "first_name")
    private String firstName;
    @Column(name = "last_name")
    private String lastName;
    @Column(name = "middle_name")
    private String middleName;

    @Enumerated(EnumType.STRING)
    @Column(name = "gender")
    private Gender gender;

    @Column(name = "login",unique = true)
    @JsonIgnore
    private String login;

    @Column(name = "password")
    @JsonIgnore
    private String password;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = "users_roles",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "role_id")
    )
    private Set<Role> roles;

    @ManyToMany(fetch = FetchType.EAGER)
    @JoinTable(
            name = "users_positions",
            joinColumns = @JoinColumn(name = "user_id"),
            inverseJoinColumns = @JoinColumn(name = "position_id")
    )
    private Set<Position> positions;

    @Column(name = "enabled")
    private Boolean enabled = true;

    @Column(name = "credentials_non_expired")
    private Boolean credentialsNonExpired = true;

    @Column(name = "account_non_locked")
    private Boolean accountNonLocked = true;

    @Column(name = "account_non_expired")
    private Boolean accountNonExpired = true;

//    @OneToMany(mappedBy = "user", fetch = FetchType.EAGER, cascade = CascadeType.ALL)
//    @JsonManagedReference
//    private List<UserPhoto> photos;


    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return this.roles;
    }

    @Override
    public String getUsername() {
        return this.login;
    }

    @Override
    public boolean isAccountNonExpired() {
        return this.accountNonExpired;
    }

    @Override
    public boolean isAccountNonLocked() {
        return this.accountNonLocked;
    }

    @Override
    public boolean isCredentialsNonExpired() {
        return this.credentialsNonExpired;
    }

    @Override
    public boolean isEnabled() {
        return this.enabled;
    }

    public User(UUID id, String firstName, String lastName, String middleName, String login, String password, Set<Role> roles) {
        super(id);
        this.firstName = firstName;
        this.lastName = lastName;
        this.middleName = middleName;
        this.login = login;
        this.password = password;
        this.roles = roles;
    }


}
```
---
# 2.2 BaseEntity
```java
package uz.pdp.archvizor.entity;

import jakarta.persistence.*;
import lombok.AllArgsConstructor;
import lombok.Data;
import lombok.NoArgsConstructor;
import org.springframework.data.annotation.CreatedBy;
import org.springframework.data.annotation.CreatedDate;
import org.springframework.data.annotation.LastModifiedBy;
import org.springframework.data.annotation.LastModifiedDate;
import org.springframework.data.jpa.domain.support.AuditingEntityListener;

import java.time.LocalDateTime;
import java.util.UUID;

@Data
@MappedSuperclass
@AllArgsConstructor
@NoArgsConstructor
@EntityListeners(AuditingEntityListener.class)
public abstract class BaseEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", updatable = false, nullable = false, columnDefinition = "uuid default uuid_generate_v4()")
    private UUID id;

    @CreatedDate
    @Column(nullable = false, name = "created_at",updatable = false)
    private LocalDateTime createdAt;

    @LastModifiedDate
    @Column(name = "updated_at")
    private LocalDateTime updatedAt;

    @CreatedBy
    @Column(nullable = false, name = "created_by")
    private UUID createdBy;

    @LastModifiedBy
    @Column(nullable = false, name = "updated_by")
    private UUID updatedBy;

 	@PreUpdate
    protected void setUpdatedAt() {
        this.updatedAt = LocalDateTime.now();
    }
}
```
# 2.3 Role
```java
package uz.pdp.archvizor.entity;

import jakarta.persistence.*;
import lombok.*;
import org.springframework.security.core.GrantedAuthority;

import java.util.Objects;
import java.util.UUID;

@Entity
@Getter
@Setter
@ToString
@AllArgsConstructor
@NoArgsConstructor
@Table(name = "roles")
public class Role implements GrantedAuthority {
    @Id
    @GeneratedValue(strategy = GenerationType.UUID)
    @Column(name = "id", updatable = false, nullable = false, columnDefinition = "uuid default uuid_generate_v4()")
    private UUID id;

    @Column(nullable = false,name = "role_name")
    private String roleName;

    @Column(nullable = false, name = "role_code")
    private String roleCode;

    @Override
    public boolean equals(Object object) {
        if (this == object) return true;
        if (object == null || getClass() != object.getClass()) return false;
        Role role = (Role) object;
        return Objects.equals(id, role.id) && Objects.equals(roleName, role.roleName) && Objects.equals(roleCode, role.roleCode);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, roleName, roleCode);
    }

    @Override
    public String getAuthority() {
        return this.roleCode;
    }
}
```
---
# 3.1 AuditingConfig
```java
package uz.pdp.archvizor.config;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.data.domain.AuditorAware;
import org.springframework.data.jpa.repository.config.EnableJpaAuditing;

import java.util.UUID;

@Configuration
@EnableJpaAuditing
public class AuditingConfig {

    /**
     * UUID - generic user ning id sini type
     * */
    @Bean
    public AuditorAware<UUID> auditorAware(){
        return new SpringSecurityAuditAwareImpl();
    }
}
```
---
# 3.2 SpringSecurityAuditAwareImpl
```java
package uz.pdp.archvizor.config;

import org.springframework.data.domain.AuditorAware;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import uz.pdp.archvizor.entity.User;

import java.util.Optional;
import java.util.UUID;

/**
 * UUID - generic user ning id sini type
 * */
public class SpringSecurityAuditAwareImpl implements AuditorAware<UUID> {

    /**
     * UUID - generic user ning id sini type
     * */
    @Override
    public Optional<UUID> getCurrentAuditor() {
        Authentication auth = SecurityContextHolder.getContext().getAuthentication();
        if (auth!=null
                &&
                auth.isAuthenticated()
                &&
                !"anonymousUser".equals(""+auth.getPrincipal())
        ){
            return Optional.of(((User)auth.getPrincipal()).getId());
        }

        return Optional.empty();
    }
}
```
---
# 4.1 JwtProvider
```java
package uz.pdp.archvizor.secret;

import io.jsonwebtoken.*;
import io.jsonwebtoken.io.Decoders;
import io.jsonwebtoken.security.Keys;
import io.jsonwebtoken.security.SignatureException;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.stereotype.Component;
import uz.pdp.archvizor.entity.User;
import uz.pdp.archvizor.repository.UserRepository;

import java.security.Key;
import java.util.Date;
import java.util.Optional;

@Component
public class JwtProvider {

    @Value("${jwt.secret.key}")
    private String SECRET_KEY;

    @Value("${jwt.secret.expired-date}")
    private Long EXPIRED_DATE;

    private final UserRepository userRepository;

    public JwtProvider(UserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public String generateToken(@NonNull String username) {
        System.out.println("--------####-----------------------------------");
        Optional<User> optionalUser = userRepository.findUserByEmail(username);

        System.out.println("-------------------------------------------");
        if (optionalUser.isPresent()) {
            User user = optionalUser.get();
            System.out.println(user + "-------------------------------------------");
            return Jwts.builder()
                    .setSubject(username)
                    .setIssuer("archvizor.uz")
                    .setIssuedAt(new Date())
                    .claim("roles", user.getRoles())
                    .setExpiration(new Date(System.currentTimeMillis() + EXPIRED_DATE))
                    .signWith(signKey(), SignatureAlgorithm.HS256)
                    .compact();
        }
        throw new BadCredentialsException("User not found");
    }

    public boolean validateToken(@NonNull String token) {
        try {
            Jwts
                    .parserBuilder()
                    .setSigningKey(signKey())
                    .build()
                    .parseClaimsJws(token)
                    .getBody();

            return true;
        } catch (ExpiredJwtException e) {
            System.err.println("Token muddati o'tgan");
            return false;
        } catch (MalformedJwtException e) {
            System.err.println("Token buzilgan");
            return false;
        } catch (SignatureException e) {
            System.err.println("Token secret key xato");
            return false;
        } catch (UnsupportedJwtException e) {
            System.err.println("Token format xato");
            return false;
        } catch (Exception e) {
            System.out.println("Token xato");
            return false;
        }

    }

    public Key signKey() {
        byte[] key = Decoders.BASE64.decode(SECRET_KEY);
        return Keys.hmacShaKeyFor(key);
    }

    public String getUsernameFromToken(String token) {
        return Jwts
                .parserBuilder()
                .setSigningKey(signKey())
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }
}
```
---
# 4.2 JwtFilter
```java
package uz.pdp.archvizor.secret;


import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.lang.NonNull;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.web.filter.OncePerRequestFilter;

import uz.pdp.archvizor.entity.User;
import uz.pdp.archvizor.repository.UserRepository;

import java.io.IOException;

public class JwtFilter extends OncePerRequestFilter {

    @Autowired
    private JwtProvider provider;

    @Autowired
    private UserRepository userRepository;


    @Override
    protected void doFilterInternal(
            @NonNull HttpServletRequest request,
            @NonNull HttpServletResponse response,
            @NonNull FilterChain filterChain
    ) throws ServletException, IOException {
        String token = getTokenFromRequest(request);

        if (token != null && provider.validateToken(token)) {
            User user = getUserFromToken(token);
            if (user != null) {
                if (user.isAccountNonExpired()) {
                    if (user.isAccountNonLocked()) {
                        if (user.isCredentialsNonExpired()) {
                            if (user.isEnabled()) {
                                UsernamePasswordAuthenticationToken authenticationToken =
                                        new UsernamePasswordAuthenticationToken(
                                                user,
                                                null,
                                                user.getAuthorities()
                                        );
                                SecurityContextHolder.getContext().setAuthentication(authenticationToken);
                            } else {
                                System.err.println("User Disabled");
                            }
                        } else {
                            System.err.println("User Credentials Expired");
                        }
                    } else {
                        System.err.println("User Locked");
                    }
                } else {
                    System.err.println("User Expired");
                }
            }
            else {
//                response.sendRedirect("/login");
//                response.sendRedirect("/login");
//                response.setStatus(401);
            }
        }

        filterChain.doFilter(request, response);
    }

    //TODO===============================
    // Token dan USER ni olish
    private User getUserFromToken(String token) {
        boolean validateToken = provider.validateToken(token);
        if (validateToken){
            String usernameFromToken = provider.getUsernameFromToken(token);
            return userRepository.findUserByEmail(usernameFromToken/*UUID.fromString(userIdFromToken)*/).get();
        }
        return null;
    }


    private String getTokenFromRequest(HttpServletRequest request) {
        String header = request.getHeader("Authorization");
        return header!=null?header.substring(7):null;
    }
}
```
---
# 4.3 application.properties fileda quyidagilarni o`zingiz berishingiz kerak. Bu JWT ning secret key va token qancha vaqt yaroqli ekanligini ifodalaydi
```properties
jwt.secret.key=e54ccb88b47fddcbc489997c7d7bc53998ce44dbb54eb7664a0ebf50d689659b
jwt.secret.expired-date=8640000
```

# 4.4 UserRepository
```java
package uz.pdp.archvizor.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import uz.pdp.archvizor.entity.User;

import java.util.Optional;
import java.util.UUID;

public interface UserRepository extends JpaRepository<User, UUID> {
    Optional<User> findUserByEmail(String email);
}
```
---
# 4.5 AuthService
```java
package uz.pdp.archvizor.secret;

import lombok.RequiredArgsConstructor;
import org.springframework.security.core.userdetails.UserDetails;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.stereotype.Service;
import uz.pdp.archvizor.repository.UserRepository;


@Service
@RequiredArgsConstructor
public class AuthService implements UserDetailsService {

    private final UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        return userRepository.findUserByEmail(username).get();
    }
}
```
---
# 4.5 CurrentUser
```java
package uz.pdp.archvizor.secret;

import org.springframework.security.core.annotation.AuthenticationPrincipal;

import java.lang.annotation.*;

@Target({ElementType.PARAMETER, ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@AuthenticationPrincipal
public @interface CurrentUser {

}
```
# 5. SecurityConfiguration
```java
package uz.pdp.archvizor.config;

import com.fasterxml.jackson.databind.ObjectMapper;
import jakarta.servlet.ServletOutputStream;
import lombok.RequiredArgsConstructor;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.method.configuration.EnableMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.config.http.SessionCreationPolicy;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.access.AccessDeniedHandler;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;
import uz.pdp.archvizor.dto.AuthErrorDTO;
import uz.pdp.archvizor.secret.JwtFilter;


import java.util.List;

@Configuration
@EnableWebSecurity
@EnableMethodSecurity
@RequiredArgsConstructor
public class SecurityConfiguration {

    private static final String[] SWAGGER_AND_ACTUATOR = {
            "/v3/api-docs/**",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/swagger-resources/**",
            "/configuration/ui",
            "/configuration/security",
            "/webjars/**",
            "/actuator/**"
    };

    public static final String[] PUBLIC_APIS = {
            "/api/v1/auth/**",
            "/api/v1/desktop/auth/**",
            "/api/v1/images/**",
            "/api/v1/user-photos/image/**"
    };

    private final ObjectMapper objectMapper;

    @Bean
    public JwtFilter filter() {
        return new JwtFilter();
    }

    @Bean
    public PasswordEncoder passwordEncoder() {
        return new BCryptPasswordEncoder();
    }

    @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration authenticationConfiguration) throws Exception {
        return authenticationConfiguration.getAuthenticationManager();
    }

    @Bean
    public SecurityFilterChain configure(final HttpSecurity http) throws Exception {
        return http
                .cors(cors -> {
                    cors.configurationSource(corsConfigurationSource());
                })
                .csrf(AbstractHttpConfigurer::disable)
                .authorizeHttpRequests(auth -> auth
                        .requestMatchers(SWAGGER_AND_ACTUATOR).permitAll()
                        .requestMatchers(PUBLIC_APIS).permitAll()
                        .anyRequest().authenticated()
                )
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))
                .exceptionHandling(exception -> exception
                        .authenticationEntryPoint(authenticationEntryPoint()) // 401 Forbidden
                        .accessDeniedHandler(accessDeniedHandler())) // 403 Forbidden
                .addFilterBefore(filter(), UsernamePasswordAuthenticationFilter.class)
                .build();
    }

    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();
        //configuration.addAllowedOriginPattern(List.of("localhost:3000","http://localhost:3000","http://localhost:8080"));
        configuration.addAllowedOriginPattern("*");
        configuration.setAllowedHeaders(List.of("*"));
        configuration.setAllowedMethods(List.of("GET", "POST", "PUT", "DELETE","PATCH"));
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        source.registerCorsConfiguration("/api/**", configuration);
        return source;
    }


    @Bean
    public AccessDeniedHandler accessDeniedHandler(){
        return ((request, response, authException) -> {
            authException.printStackTrace();
            String errorPath = request.getRequestURI();
            String errorMessage = authException.getMessage() + ". You do not have permission or role to access this resource";
            AuthErrorDTO authErrorDTO = new AuthErrorDTO(errorMessage, errorPath, 403);
            response.setStatus(403);
            ServletOutputStream outputStream = response.getOutputStream();
            objectMapper.writeValue(outputStream, authErrorDTO);
        });
    }

    @Bean
    public AuthenticationEntryPoint authenticationEntryPoint(){
        return ((request, response, authException) -> {
            authException.printStackTrace();
            String errorPath = request.getRequestURI();
            String errorMessage = authException.getMessage() + ". You are not authorized to access this resource";
            AuthErrorDTO authErrorDTO = new AuthErrorDTO(errorMessage, errorPath, 401);
            response.setStatus(401);
            ServletOutputStream outputStream = response.getOutputStream();
            objectMapper.writeValue(outputStream, authErrorDTO);
        });
    }
}
```
---
# 6.1 CustomAuthService
```java
package uz.pdp.archvizor.service;


import org.apache.coyote.BadRequestException;
import uz.pdp.archvizor.dto.auth.AuthResponse;
import uz.pdp.archvizor.dto.auth.LoginDto;

public interface CustomAuthService {
    AuthResponse login(LoginDto dto) throws BadRequestException;
}
```
---
# 6.2 CustomAuthImplService
```java
package uz.pdp.archvizor.service.impl;

import org.apache.coyote.BadRequestException;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Service;
import uz.pdp.archvizor.dto.auth.AuthResponse;
import uz.pdp.archvizor.dto.auth.LoginDto;
import uz.pdp.archvizor.entity.User;
import uz.pdp.archvizor.secret.JwtProvider;
import uz.pdp.archvizor.service.CustomAuthService;

@Service
public class CustomAuthImplService implements CustomAuthService {
    private final AuthenticationManager authenticationManager;
    private final JwtProvider jwtProvider;

    public CustomAuthImplService(AuthenticationManager authenticationManager, JwtProvider jwtProvider) {
        this.authenticationManager = authenticationManager;
        this.jwtProvider = jwtProvider;
    }

    @Override
    public AuthResponse login(LoginDto dto) throws BadRequestException {
        try {
            Authentication authenticate = authenticationManager.authenticate(
                    new UsernamePasswordAuthenticationToken(
                            dto.login(),
                            dto.password()
                    )
            );
            SecurityContextHolder.getContext().setAuthentication(authenticate);
            User user = (User) authenticate.getPrincipal();
            String token = jwtProvider.generateToken(user);
            return new AuthResponse(token);
        } catch (Exception e) {
            throw new BadRequestException("Error: Invalid login or password.");
        }
    }
}
```
# 6.3 LoginDto
```java
package uz.pdp.archvizor.dto.auth;

import com.fasterxml.jackson.annotation.JsonProperty;
import jakarta.validation.constraints.NotBlank;

public record LoginDto(
        @JsonProperty("login")
//        @ValidLogin
        String login,
        @NotBlank(message = "password is not valid.")
        @JsonProperty("password")
        String password
) {
}
```
---
# 6.4 AuthResponse
```java
package uz.pdp.archvizor.dto.auth;

public class AuthResponse {
    private String accessToken;
    private String tokenType = "Bearer";

    public AuthResponse(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getAccessToken() {
        return accessToken;
    }

    public void setAccessToken(String accessToken) {
        this.accessToken = accessToken;
    }

    public String getTokenType() {
        return tokenType;
    }

    public void setTokenType(String tokenType) {
        this.tokenType = tokenType;
    }
}
```
