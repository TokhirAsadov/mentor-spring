## ğŸ§© **AOP (Aspect-Oriented Programming) â€” Aspektga yoâ€˜naltirilgan dasturlash**

> **Modularize cross-cutting concerns**, bu degani â€” *turli joylarda takrorlanuvchi vazifalarni* bitta joyga toâ€˜plab, kerak boâ€˜lgan joylarda avtomatik tarzda ishlatish.

---

### ğŸ“Œ **Cross-cutting concerns** â€” "Koâ€˜p joyda takrorlanuvchi masalalar"

Quyidagilar AOP orqali modullashtiriladigan umumiy masalalardir:

1. **Auditing** â€“ kim, qachon, qanday amal bajarganini yozib borish
2. **Logging** â€“ jarayonlar haqida log yozish (masalan, `INFO`, `ERROR`)
3. **Security** â€“ foydalanuvchi ruxsatlari, autentifikatsiya
4. **Transaction** â€“ `commit`/`rollback` boshqaruvi
5. **Monitoring** â€“ tizim holatini kuzatish
6. **Cache** â€“ maâ€™lumotlarni vaqtincha saqlash
7. **Business Rules** â€“ umumiy biznes qoidalar
8. **Error Handling** â€“ xatolarni tutish va boshqarish

**ğŸŸ¡ Bu masalalar bir nechta komponentlarda ishlatilgani sababli â€œcross-cuttingâ€ deb ataladi.**

---

### âŒ **Modullashtirishsiz muammolar (Problems without modularization):**

#### 1. **Code scattering** â€“ Kodning har yerga tarqalib ketishi

> Maâ€™nosi: bir xil logika (masalan, log yozish) bir nechta joylarda **takror-takror yoziladi**.
> âš ï¸ Bu esa **kodni oâ€˜qish va qoâ€˜llab-quvvatlashni qiyinlashtiradi**.

#### 2. **Code tangling** â€“ Kodning chalkashib ketishi

> Yaâ€™ni, biznes mantiq ichiga *audit, log, xavfsizlik kabi* boshqa kodlar aralashib ketadi.
> â• "Jack of all trades" degani â€” *hamma ishni bajarayotgandek koâ€˜ringan, lekin hech birini mukammal bajarmayotgan kod*.
> ğŸ”´ Kodni **test qilish qiyinlashadi**, `unit test` deyarli imkonsiz boâ€˜ladi.

---

## âœ… Yechim: AOP bilan modularizatsiya qilish

ğŸŸ¢ AOP orqali bu muammolarni bartaraf etish mumkin:

* Kod faqat **bitta joyga yoziladi**, kerakli joylarda avtomatik ishlaydi.
* Kod **tartibli**, **sinflar toza**, va **test qilish oson** boâ€˜ladi.

---

## ğŸ’¡ Yakuniy tavsiya

Agar siz **audit**, **log**, yoki **security** bilan shugâ€˜ullanayotgan boâ€˜lsangiz va bu kodni har bir service yoki controllerda yozishga majbursiz â€” AOP bu muammoni yechadi.

---

# Example
---

### ğŸ“Œ 1. Maven dependency (`pom.xml`):

```xml
<dependencies>
    <!-- Spring Core -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-context</artifactId>
        <version>5.3.30</version>
    </dependency>

    <!-- AspectJ -->
    <dependency>
        <groupId>org.springframework</groupId>
        <artifactId>spring-aspects</artifactId>
        <version>5.3.30</version>
    </dependency>
</dependencies>
```

---

### ğŸ“Œ 2. Asosiy Service class (Target class):

```java
package uz.tohir.service;

public class PaymentService {

    public void makePayment() {
        System.out.println("ğŸ’³ Payment is being processed...");
    }

    public void cancelPayment() {
        System.out.println("âŒ Payment has been cancelled.");
    }
}
```

---

### ğŸ“Œ 3. Aspect class:

```java
package uz.tohir.aspect;

import org.aspectj.lang.annotation.Aspect;
import org.aspectj.lang.annotation.Before;
import org.aspectj.lang.annotation.After;
import org.aspectj.lang.annotation.AfterReturning;
import org.aspectj.lang.annotation.AfterThrowing;
import org.aspectj.lang.annotation.Around;
import org.aspectj.lang.ProceedingJoinPoint;
import org.springframework.stereotype.Component;

@Aspect
@Component
public class LoggingAspect {

    @Before("execution(* uz.tohir.service.PaymentService.makePayment(..))")
    public void beforePayment() {
        System.out.println("ğŸ”” [Before] About to make a payment...");
    }

    @After("execution(* uz.tohir.service.PaymentService.makePayment(..))")
    public void afterPayment() {
        System.out.println("âœ… [After] Payment method executed.");
    }

    @AfterReturning("execution(* uz.tohir.service.PaymentService.makePayment(..))")
    public void afterReturning() {
        System.out.println("ğŸ“¦ [AfterReturning] Payment completed successfully.");
    }

    @AfterThrowing("execution(* uz.tohir.service.PaymentService.makePayment(..))")
    public void afterThrowing() {
        System.out.println("ğŸš¨ [AfterThrowing] An error occurred during payment.");
    }

    @Around("execution(* uz.tohir.service.PaymentService.makePayment(..))")
    public Object aroundAdvice(ProceedingJoinPoint joinPoint) throws Throwable {
        System.out.println("ğŸ”„ [Around] Before actual payment logic");
        Object result = joinPoint.proceed();
        System.out.println("ğŸ”„ [Around] After actual payment logic");
        return result;
    }
}
```

---

### ğŸ“Œ 4. Spring Configuration class:

```java
package uz.tohir.config;

import org.springframework.context.annotation.ComponentScan;
import org.springframework.context.annotation.Configuration;
import org.springframework.context.annotation.EnableAspectJAutoProxy;

@Configuration
@ComponentScan(basePackages = "uz.tohir")
@EnableAspectJAutoProxy
public class AppConfig {
}
```

---

### ğŸ“Œ 5. Main method:

```java
package uz.tohir;

import org.springframework.context.annotation.AnnotationConfigApplicationContext;
import uz.tohir.config.AppConfig;
import uz.tohir.service.PaymentService;

public class Application {
    public static void main(String[] args) {
        var context = new AnnotationConfigApplicationContext(AppConfig.class);

        PaymentService paymentService = context.getBean(PaymentService.class);
        paymentService.makePayment();

        System.out.println("\n---\n");

        paymentService.cancelPayment();
    }
}
```

---

### ğŸ” Natija (Console chiqishi):

```text
ğŸ”” [Before] About to make a payment...
ğŸ”„ [Around] Before actual payment logic
ğŸ’³ Payment is being processed...
ğŸ”„ [Around] After actual payment logic
âœ… [After] Payment method executed.
ğŸ“¦ [AfterReturning] Payment completed successfully.

---

âŒ Payment has been cancelled.
```

---

### ğŸ“ Qoâ€˜shimcha tushuntirish:

| Annotation        | Maâ€™nosi                                             |
| ----------------- | --------------------------------------------------- |
| `@Before`         | Metod chaqilishidan oldin ishlaydi                  |
| `@After`          | Metod bajarilib boâ€˜lgandan soâ€˜ng ishlaydi           |
| `@AfterReturning` | Metod muvaffaqiyatli tugasa, ishlaydi               |
| `@AfterThrowing`  | Metodda xatolik chiqsa, shu paytda ishlaydi         |
| `@Around`         | Metodni toâ€˜liq oâ€˜rab oladi: oldin va keyin ishlaydi |


